
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Welcome to gproc’s documentation! &#8212; gproc 0.0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="static/documentation_options.js"></script>
    <script src="static/jquery.js"></script>
    <script src="static/underscore.js"></script>
    <script src="static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="module-gproc.laplace">
<span id="welcome-to-gproc-s-documentation"></span><h1>Welcome to gproc’s documentation!<a class="headerlink" href="#module-gproc.laplace" title="Permalink to this headline">¶</a></h1>
<p>Provides functions for performing Laplace approximations to GP classification posteriors.</p>
<dl class="py function">
<dt class="sig sig-object py" id="gproc.laplace.chol_inverse">
<span class="sig-prename descclassname"><span class="pre">gproc.laplace.</span></span><span class="sig-name descname"><span class="pre">chol_inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symmetric_x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gproc.laplace.chol_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Cholesky decomposition x=LL^T, and uses this to compute the inverse of X.
Only valid for symmetric x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>symmetric_x</strong> (<em>num_observations x num_observations numpy array</em>) – no symmetry checks are performed</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>x_inv</strong> – <span class="math notranslate nohighlight">\(x^{-1}\)</span>, the inverse of symmetric_x</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>num_observations x num_observations numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gproc.laplace.laplace_approximation_probit">
<span class="sig-prename descclassname"><span class="pre">gproc.laplace.</span></span><span class="sig-name descname"><span class="pre">laplace_approximation_probit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">observed_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse_gram</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gproc.laplace.laplace_approximation_probit" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the laplace approximation to the latent function implied by the model:</p>
<div class="math notranslate nohighlight">
\[p(y_i | f_i) = \Phi(y_i * f_i)\]</div>
<div class="math notranslate nohighlight">
\[p(f | K) = \mathcal{N}(0, K)\]</div>
<p>Where <span class="math notranslate nohighlight">\(\Phi\)</span> is the standard normal CDF and K is a gram matrix.</p>
<p>We target the posterior:</p>
<div class="math notranslate nohighlight">
\[p(f | y) \propto p(y | f)p(f | gram)\]</div>
<p>with the Laplace approximation <span class="math notranslate nohighlight">\(q(f) = \mathcal{N}(\mu, \Sigma)\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y</strong> (<em>num_observations x 1 numpy array</em>) – array containing 1 or -1, the observations</p></li>
<li><p><strong>inverse_gram</strong> (<em>num_observations x num_observations numpy array</em>) – the precomputed inverse gram matrix corresponding to the observations</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>returns proposed_f: num_observations x 1 numpy array, the mean of the Laplace approximation</em></p></li>
<li><p>returns df_ll: num_observations x 1 numpy array, the gradient of the log-likelihood wrt each <span class="math notranslate nohighlight">\(f_i\)</span></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-gproc.generative"></span><p>Functions for generating example classification problems.</p>
<dl class="py function">
<dt class="sig sig-object py" id="gproc.generative.sample_at_x">
<span class="sig-prename descclassname"><span class="pre">gproc.generative.</span></span><span class="sig-name descname"><span class="pre">sample_at_x</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_fcn=&lt;function</span> <span class="pre">squared_exponential&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_params={}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">likelihood=&lt;bound</span> <span class="pre">method</span> <span class="pre">rv_continuous.cdf</span> <span class="pre">of</span> <span class="pre">&lt;scipy.stats._continuous_distns.norm_gen</span> <span class="pre">object&gt;&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gproc.generative.sample_at_x" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples a class label at each provided input point according to the GP classification model.
Allows arbitrary kernel function and likelihood.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>N x D numpy array</em>) – Array of the input locations at which to draw samples.</p></li>
<li><p><strong>kernel_fcn</strong> (fcn: <span class="math notranslate nohighlight">\(\mathbb{R}^{N × D} × \mathbb{R}^{M × D} → \mathbb{R}^{N × M}\)</span>) – Kernel function which produces gram matrix given two sets of inputs</p></li>
<li><p><strong>kernel_params</strong> (<em>dict</em>) – kwargs to pass on to the kernel function</p></li>
<li><p><strong>likelihood</strong> (fcn: <span class="math notranslate nohighlight">\(\mathbb{R}^{N} → (0, 1)^{N}\)</span>) – The likelihood of a positive samples given the latent function <span class="math notranslate nohighlight">\(p(y=1 | f)\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>y</strong> (<em>N x 1 numpy integer array</em>) – The sampled class labels, either +1 or -1</p></li>
<li><p><strong>prob_y</strong> (<em>N x 1 numpy array</em>) – The probability of a positive sample at each point</p></li>
<li><p><strong>f</strong> (<em>N x 1 numpy array</em>) – The latent function value at each input point.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-gproc.kernels"></span><p>A number of python kernels, as defined in <a class="reference external" href="https://www.cs.toronto.edu/~duvenaud/cookbook/">https://www.cs.toronto.edu/~duvenaud/cookbook/</a></p>
<dl class="py function">
<dt class="sig sig-object py" id="gproc.kernels.add">
<span class="sig-prename descclassname"><span class="pre">gproc.kernels.</span></span><span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernels</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gproc.kernels.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add together an arbitrary number of kernels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_1</strong> (<em>N x D numpy array</em>) – </p></li>
<li><p><strong>x_2</strong> (<em>M x D numpy array</em>) – </p></li>
<li><p><strong>kernels</strong> (<em>iterable</em><em>(</em><em>(</em><em>kernel_fnc</em><em>, </em><em>kernel_parameters</em><em>)</em><em>, </em><em>...</em><em>)</em>) – A number of kernel function and parameter tuples.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>K</strong> – The corresponding kernel matrix <span class="math notranslate nohighlight">\(K_{ij} = k(x_i, x_j) = \sum_{l=1}^{L}k_l(x_i, x_j)\)</span>,
for L kernels.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>N x M matrix,</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gproc.kernels.linear">
<span class="sig-prename descclassname"><span class="pre">gproc.kernels.</span></span><span class="sig-name descname"><span class="pre">linear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant_variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gproc.kernels.linear" title="Permalink to this definition">¶</a></dt>
<dd><p>A linear kernel is a non-stationary kernel, which when used with a GP, is equivalent to
Bayesian linear regression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_1</strong> (<em>N x D numpy array</em>) – </p></li>
<li><p><strong>x_2</strong> (<em>M x D numpy array</em>) – </p></li>
<li><p><strong>constant_variance</strong> (<em>float</em>) – Controls height of function at 0</p></li>
<li><p><strong>variance</strong> (<em>float</em>) – The average distance from the mean</p></li>
<li><p><strong>offset</strong> (<em>float</em>) – x coordinate of location all functions go through</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>K</strong> – The corresponding kernel matrix <span class="math notranslate nohighlight">\(K_{ij} = k(x_i, x_j)\)</span></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>N x M matrix,</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gproc.kernels.locally_periodic">
<span class="sig-prename descclassname"><span class="pre">gproc.kernels.</span></span><span class="sig-name descname"><span class="pre">locally_periodic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lengthscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">period</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gproc.kernels.locally_periodic" title="Permalink to this definition">¶</a></dt>
<dd><p>A squared exponential kernel multiplied by a periodic kernel. Allows one to model periodic functions
which can vary slowly over time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_1</strong> (<em>N x D numpy array</em>) – </p></li>
<li><p><strong>x_2</strong> (<em>M x D numpy array</em>) – </p></li>
<li><p><strong>lengthscale</strong> (<em>float</em>) – Lower lengthscale gives “wigglier” functions</p></li>
<li><p><strong>variance</strong> (<em>float</em>) – The average distance from the mean</p></li>
<li><p><strong>period</strong> (<em>float</em>) – Distance between repititions</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>K</strong> – The corresponding kernel matrix <span class="math notranslate nohighlight">\(K_{ij} = k(x_i, x_j)\)</span></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>N x M matrix,</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gproc.kernels.multiply">
<span class="sig-prename descclassname"><span class="pre">gproc.kernels.</span></span><span class="sig-name descname"><span class="pre">multiply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernels</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gproc.kernels.multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply together an arbitrary number of kernels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_1</strong> (<em>N x D numpy array</em>) – </p></li>
<li><p><strong>x_2</strong> (<em>M x D numpy array</em>) – </p></li>
<li><p><strong>kernels</strong> (<em>iterable</em><em>(</em><em>(</em><em>kernel_fnc</em><em>, </em><em>kernel_parameters</em><em>)</em><em>, </em><em>...</em><em>)</em>) – A number of kernel function and parameter tuples.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>K</strong> – The corresponding kernel matrix <span class="math notranslate nohighlight">\(K_{ij} = k(x_i, x_j) = \prod_{l=1}^{L}k_l(x_i, x_j)\)</span>,
for L kernels.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>N x M matrix,</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gproc.kernels.periodic">
<span class="sig-prename descclassname"><span class="pre">gproc.kernels.</span></span><span class="sig-name descname"><span class="pre">periodic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lengthscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">period</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gproc.kernels.periodic" title="Permalink to this definition">¶</a></dt>
<dd><p>The periodic kernel allows one to model functions which repeat themselves exactly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_1</strong> (<em>N x D numpy array</em>) – </p></li>
<li><p><strong>x_2</strong> (<em>M x D numpy array</em>) – </p></li>
<li><p><strong>lengthscale</strong> (<em>float</em>) – Lower lengthscale gives “wigglier” functions</p></li>
<li><p><strong>variance</strong> (<em>float</em>) – The average distance from the mean</p></li>
<li><p><strong>period</strong> (<em>float</em>) – Distance between repititions</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>K</strong> – The corresponding kernel matrix <span class="math notranslate nohighlight">\(K_{ij} = k(x_i, x_j)\)</span></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>N x M matrix,</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gproc.kernels.rational_quadratic">
<span class="sig-prename descclassname"><span class="pre">gproc.kernels.</span></span><span class="sig-name descname"><span class="pre">rational_quadratic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lengthscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gproc.kernels.rational_quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Rational Quadratic Kernel, equivalent to adding together many Squared Exponential kernels with different
lengthscales. Weight parameter determine relative weighting of large and small scale variations. When
the weighting goes to infinity, RQ = SE.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_1</strong> (<em>N x D numpy array</em>) – </p></li>
<li><p><strong>x_2</strong> (<em>M x D numpy array</em>) – </p></li>
<li><p><strong>lengthscale</strong> (<em>float</em>) – Lower lengthscale gives “wigglier” functions</p></li>
<li><p><strong>variance</strong> (<em>float</em>) – The average distance from the mean</p></li>
<li><p><strong>weighting</strong> (<em>float</em>) – Relative weighting of large and small scale variations</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>K</strong> – The corresponding kernel matrix <span class="math notranslate nohighlight">\(K_{ij} = k(x_i, x_j)\)</span></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>N x M matrix,</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gproc.kernels.squared_exponential">
<span class="sig-prename descclassname"><span class="pre">gproc.kernels.</span></span><span class="sig-name descname"><span class="pre">squared_exponential</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lengthscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gproc.kernels.squared_exponential" title="Permalink to this definition">¶</a></dt>
<dd><p>Also known as RBF.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_1</strong> (<em>N x D numpy array</em>) – </p></li>
<li><p><strong>x_2</strong> (<em>M x D numpy array</em>) – </p></li>
<li><p><strong>lengthscale</strong> (<em>float</em>) – Lower lengthscale gives “wigglier” functions</p></li>
<li><p><strong>variance</strong> (<em>float</em>) – The average distance from the mean</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>K</strong> – The corresponding kernel matrix <span class="math notranslate nohighlight">\(K_{ij} = k(x_i, x_j)\)</span></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>N x M matrix,</p>
</dd>
</dl>
</dd></dl>

<div class="toctree-wrapper compound">
</div>
</section>
<section id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="#">gproc</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Tennessee Hickling, Dominic Broadbent, Edward Milson.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.4.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>